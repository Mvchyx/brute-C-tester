#!/bin/sh

HW=01 # can be hardcoded in by commenting out the 3 lines below

# takes the HW number from the end of the working directory
SCRIPT_DIR="$PWD"
FOLDER_NAME="${SCRIPT_DIR##*/}"
HW=$(echo "$FOLDER_NAME" | sed 's/.*\(..\)$/\1/') # usable also in POSIX to extract last two char

PROGRAM_REF=./b3b36prg-hw$HW-genref
NC_PROGRAM_MY=main.c # my program not compiled
PROGRAM_MY=./a.out
COMPILATOR=gcc

# used as bool
correct=1

# used by flags
hex_mode=0
random_mode=0
valgrind=""
compile=0
dump=0
input=0

# get the flags and make the corresponding vars true 
# what each flag does is clear from the config table below
while getopts "xrvcdi" flag; do
    case "${flag}" in
        x) hex_mode=1 ;;
        r) random_mode=1 ;;
        v) valgrind="valgrind -q --leak-check=yes --log-file=valgrind_leak.log --error-exitcode=42"  ;;
        c) compile=1 ;;
        d) dump=1 ;;
        i) input=1 ;;
    esac
done

# nicely display what's on and what's off
echo "========================================"
echo "          TEST CONFIGURATION            "
echo "========================================"

printf " Compilation (-c)     : %s\n" "$([ "$compile" -eq 1 ] && echo "ON" || echo "OFF")"
printf " Valgrind (-v)        : %s\n" "$([ -n "$valgrind" ] && echo "ON" || echo "OFF")"
printf " Hex diff (-x)        : %s\n" "$([ "$hex_mode" -eq 1 ] && echo "ON" || echo "OFF")"
printf " Random (-r)          : %s\n" "$([ "$random_mode" -eq 1 ] && echo "ON" || echo "OFF")"
printf " Entire dump (-d)     : %s\n" "$([ "$dump" -eq 1 ] && echo "ON" || echo "OFF")"
printf " Manual Input (-i)    : %s\n" "$([ "$input" -eq 1 ] && echo "ON" || echo "OFF")"

echo "========================================"
echo ""

# if desired compile the script
if [ $compile -eq 1 ]; then
    $COMPILATOR -g $NC_PROGRAM_MY || { echo "Compilation failed aborting"; exit 1; }
fi

if [ $input -eq 1 ] && [ $random_mode -eq 1 ]; then
    echo "Warning: random mode with manual input on -> only manual input"
fi

# radnom or pub mode based on the given flag, added manual input mode it is tuged together with random mode
# in a pub mode it compares the reference solution and mine and stops when they differ
if [ $random_mode -eq 1 ] || [ $input -eq 1 ]; then
    mkdir -p my_random_data #create folder for files generated by the random or single input solution 
    #(in random mode just the last file stays their)
    for i in `seq 1 100`
    do
        PROBLEM=my_random_data/hw$HW # custom naming
        MY_SOLUTION=my_random_data/my_hw$HW # custom naming
        # generate random input
        $PROGRAM_REF -generate > $PROBLEM.in 2>/dev/null

        # manual input, prompt for it
        if [ $input -eq 1 ]; then
            echo "Enter the test data (press Ctrl+D on a new line when finished): "
            cat > $PROBLEM.in # reads directly from the terminal
            echo "" # make it cleaner
        fi
        
        # get their solution to the problem
        $PROGRAM_REF < $PROBLEM.in > $PROBLEM.out 2>$PROBLEM.err

        start_time=$(date +%s%3N) #start timer
        # get my solution to the problem
        $valgrind $PROGRAM_MY < $PROBLEM.in > $MY_SOLUTION.out 2>$MY_SOLUTION.err
        
        valgrind_status=$? # catch last return value in this case from valgrind            
        end_time=$(date +%s%3N) # end timer
        run_time=$(($end_time - $start_time)) # final time
        
        # check valgrind error
        if [ "$valgrind_status" -eq 42 ]; then
            printf "\n Test $i memory leak detected:"
            cat valgrind_leak.log # show the valgrind error (it is put away to its own file to not collide with stderr)
            correct=0
        fi

        # compare the solutions normally and print the outcome
        diff $MY_SOLUTION.out $PROBLEM.out && diff $MY_SOLUTION.err $PROBLEM.err
        if [ $? -eq 0 ]; then
            echo "Test $i is correct (${run_time}ms)"
        else
            printf "\n Test $i is not correct (Your output is the first)\n"
            correct=0
            if [ $dump -eq 1 ]; then
                cat $PROBLEM.out.hex
                printf "\n\n"
                cat $MY_SOLUTION.out.hex
                printf "\n\n"
            fi
        fi

        # if -x compare the solutions also in the hex form
        if [ $hex_mode -eq 1 ] && [ $correct -eq 0 ]; then
            hexdump -C $MY_SOLUTION.out > $MY_SOLUTION.out.hex
            hexdump -C $PROBLEM.out > $PROBLEM.out.hex

            if [ $dump -eq 1 ]; then
                cat $PROBLEM.out.hex
                printf "\n\n"
                cat $MY_SOLUTION.out.hex
                printf "\n\n"
            fi

            diff $MY_SOLUTION.out.hex $PROBLEM.out.hex
        fi

        # stop at an incorrect solution or if single input is on
        if [ $correct -eq 0 ] || [ $input -eq 1 ]; then
            break
        fi

    done

else
    mkdir -p my_data

    # loops through all files in data that ends .in
    for FILE in data/*.in;
    do
        # do this only if the file with the corresponding name exists
        if test -f $FILE; then
            number=$(echo "$FILE" | sed 's/^[^0-9]*\([0-9]*\).*$/\1/') # extracts first occurence of a number in the file name
            MY_SOLUTION=my_data/my_pub$number # where I want my solutions to be saved
            PROBLEM="${FILE%.in}" # strip away the .in
                    
            start_time=$(date +%s%3N) #start timer
            # run my program
            $valgrind $PROGRAM_MY < $PROBLEM.in > $MY_SOLUTION.out 2> $MY_SOLUTION.err
            valgrind_status=$? # catch valgrind return message
            end_time=$(date +%s%3N) # end timer
            run_time=$(($end_time - $start_time)) # final time


            # check valgrind error           
            if [ "$valgrind_status" -eq 42 ]; then
                printf "\n Pub test $number ("${PROBLEM##*/}") memory leak detected:"
                cat valgrind_leak.log # show the valgrind error
                correct=0
            fi

            # compare my solution with theirs and print the outcome, iff .err exists compare also against it
            if test -f $PROBLEM.err; then
                diff $MY_SOLUTION.out $PROBLEM.out && diff $MY_SOLUTION.err $PROBLEM.err
            else
                diff $MY_SOLUTION.out $PROBLEM.out
            fi
            if [ $? -eq 0 ]; then
                echo "Pub test $number ("${PROBLEM##*/}") is correct (${run_time}ms)"
            else
                printf "\n Pub test $number ("${PROBLEM##*/}") is not correct (Your output is the first)\n"
                correct=0
                if [ $dump -eq 1 ]; then
                    cat $PROBLEM.out
                    printf "\n\n"
                    cat $MY_SOLUTION.out
                    printf "\n\n"
                fi
            fi

            # if -x compare it also in the hex form
            if [ $hex_mode -eq 1 ] && [ $correct -eq 0 ]; then
                hexdump -C $MY_SOLUTION.out > $MY_SOLUTION.out.hex

                if !(test -f $PROBLEM.out.hex); then
                    hexdump -C $PROBLEM.out > $PROBLEM.out.hex
                fi

                if [ $dump -eq 1 ]; then
                    cat $PROBLEM.out.hex
                    printf "\n\n"
                    cat $MY_SOLUTION.out.hex
                    printf "\n\n"
                fi

                diff $MY_SOLUTION.out.hex $PROBLEM.out.hex

            fi

            # stop at an incorrect solution
            if [ $correct -eq 0 ]; then
                break
            fi
        else
            echo "Error loading files: The folder is probably empty"
            exit 1
        fi
    done
fi

# Clean up the hidden Valgrind log
rm -f valgrind_leak.log
